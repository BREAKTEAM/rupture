\subsection{One-shot attack}

\begin{lemma}[Compression attack]

Let $\textrm{Com}$ be a compression function, $\textrm{Enc}$ be a strictly length-monotonic
encryption function, $f$ be a rendering function and $Q$ be a plaintext
predicate detectable with non-negligible advantage $\alpha$ over plaintext
distribution $\mathcal{M}$.

Then:
\begin{align*}
    \exists \alpha \text{ non-negl}:
    \forall \textrm{Enc}:
    \exists g:\\
    \exists PPT \mathcal{A}:
    \forall PPT \mathcal{S}:\\
    \text{Adv}_{\mathcal{SE}(\textrm{Enc}, \textrm{Com}), \mathcal{A}, \mathcal{S}}
    (\lambda, f, \mathcal{M}, g) = \alpha(\lambda)
\end{align*}

\end{lemma}

For a full proof, see Appendix A.

\subsection{Amplified attack}\label{subsec:amplification}

We can now amplify the attack to achieve a better probability of success by a small modification in our adversary.
The amplification is parameterized by an odd parameter $k$.

Let the amplification adversary be defined as follows:

\begin{lstlisting}[texcl,mathescape,basicstyle=\small]
def $\mathcal{A}(Q, \mathcal{M})$:
    $(r_1, r_2) \leftarrow \mathcal{O}_R(\textrm{Com}, f, Q, \mathcal{M})$

    $low = 0$
    $high = 0$

    for $i$ = $0$ to $k$:
        $l_1 = |\text{Reflect}^{\mathcal{E}_{pk}}_s(r_1)|$
        $l_2 = |\text{Reflect}^{\mathcal{E}_{pk}}_s(r_2)|$

        if $l_1 < l_2$:
            $low = low + 1$
        else:
            $high = high + 1$

    if $low > high$:
        return True
    else:
        return False
\end{lstlisting}

\begin{lemma}[Amplification]

Under the assumptions of the Compression Attack Theorem against $f, \textrm{Com}$
and compression-detectable predicate $Q$ with non-negligible
detectability margin $\alpha(\lambda)$,
the amplified adversary achieves an arbitrarily large advantage
against a non-negligible subset of elements, the
\textit{amplifiable elements} distinguished by predicate $Amp$.
\begin{align*}
    \forall \textrm{Enc}:
    \exists g:\\
    \exists PPT \mathcal{A}:
    \forall PPT \mathcal{S}:\\
    \exists Amp:
    \exists B \text{ non-negl}:
    \exists C \text{ negl}:\\
    \Pr_{s \leftarrow \mathcal{M}}[Amp(s)] = B(\lambda) \land\\
    \text{Adv}_{\mathcal{SE}(\textrm{Enc}, \textrm{Com}), \mathcal{A}, \mathcal{S}_{Amp}}
    (\lambda, f, \mathcal{M}, g) = 1 - \pi - C(k)
\end{align*}

\end{lemma}

The complete proof can be found in Appendix A.

\subsection{Reflection game instances}
Having established our theoretical model we now describe BREACH, CRIME, and TIME
as reflection game instances. These attack share some common functionality
features that we describe, before elaborating on each one separately.

The encryption algorithm and key are included in the implementation of the TLS
protocol. In most real-world systems, the encryption algorithm is AES and the
key is typically 128 or 256 bits. This is represented by the $\textrm{Enc}$ and
the $Gen$ functions, whereas the AES key used for the TLS application data is
$sk$. The ciphertext $c$ is the encrypted output of the encryption function.

The support of the distribution $\mathcal{M}$ contains all strings that consist
of a known prefix, that the adversary need to bootstrap the attack, concatenated
with each character in the secret's alphabet.

The adversary issues consecutive requests, each containing a reflection. The
secret exists in the support of $\mathcal{M}$ and one of the reflections is
bound to match it. The goal of the adversary is to recognize which reflection
that is.

In cases when $r$ matches a prefix of the secret $s$, the probability
of this prefix in $c$ will be greater than in cases of no match.
Given this interdependence between the secret and the reflection the predicate
$Q$ of the secret is compression detectable by the reflection set. The
reflection vector $\bar{r}$ contains all reflection strings $r_1, r_2, ...$.

The predicate $Q$ in this case checks whether the prefix of $s$ is equal to a
certain value. Specifically, when $Q$ is detectable, the adversary is able to
find if the length of $c_1$ containing the reflection $r_1$ is less than $c_2$
which contains the reflection $r_2$, so that the interdependence and compression
idealness lead the adversary to conclude that $r_1$ is a prefix of $s$.

\subsubsection{BREACH}
The adversary that issues the BREACH attack fulfills the assumptions described
in section \ref{subsec:example}. The challenger is the server that handles the
user's request. The secret $s$ is a data element in the response, in the
original BREACH paper a CSRF token.

The reflection oracle is the web application framework and the underlying web
server that uses modules for compression and encryption. The final part of the
oracle, sending the ciphertext $c_i$ to the adversary, is impemented by the
Man-in-the-Middle module that gives the adversary the ability to monitor the
user's network traffic.

The rendering function $f$ is the backend that generates the HTML response code.
The response is compressed, the most commonly by the DEFLATE algorithm. The
DEFLATE algorithm is the $\textrm{Com}$ function in the context of the
reflection game.

\subsubsection{CRIME}
The main difference of CRIME is that it targets HTTP requests instead of
responses. The challenger and the oracle exist now in the user's browser. The
secret $s$ is a Cookie that is included in the request. The rendering function
$f$ is the browser's function that crafts the request payload.

The rest of the parameters are the same as in BREACH. The adversary follows the
same strategy in order to craft the reflections $r_1$ and $r_2$, compare
different size lengths of requests that contain each one along with $s$ and
decrypt a prefix of $s$.

\subsubsection{TIME}
The TIME attack's novelty is the absence of a MitM module and the usage of a
time side-channel. In this case, the adversary does not have access to the
length but the timings of the responses. The time until the response is complete
depends on the response length, since a longer response results in slower
network transmission.

The main difference of TIME is the oracle. In TIME the last part of the
oracle, sending the ciphertext $c$ to the adversary, is implemented in the same
script that issues the requests. Also the oracle does not send $c$ to the
adversary, but rather an approximation of $\rvert c \rvert$.
