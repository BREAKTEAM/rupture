\section{The attack}\label{sec:attack}

\subsection{A high-level overview}\label{subsec:example}
As explained above, compression side-channel attacks pose a serious threat
against real-world deployments of TLS and in general of any encryption system.
Although widely received and documented by the security community, there are
still not many existing mitigation strategies to thwart them, primarily due to
(i) the perceived high performance penalty associated with mitigating them, and
(ii) their perceived complexity and the lack of production code tools that allow
for their robust execution, something that makes some believe they are not a
realistic threat. In this work we illustrate that these perceptions are
wrong and the continuous existence of these attacks suggests a grave
situation that needs to be addressed.

In order to appreciate the seriousness of these attacks we present a motivating
example. Suppose that a user browses the Internet and accesses a website, like a
social network, e-banking, mail provider or a similar service that handles
sensitive private data. When the server receives a request for a page it
collects all needed data, generates the HTML code for the page and sends a
network response containing this code along with other resources such as images
and libraries. All response data is encrypted under TLS, which ensures privacy
and integrity for the communication between the user and the server, and
compressed for efficiency.

Consider now an adversary that aims to break this communication's security.
This adversary tries to decrypt parts of the communication and reveal
information about the exchanged private data. However, in order to mount a
compression side-channel attack certain conditions need be met.

Firstly, the adversary is able to handle the user's network traffic. That way he
is able to collect and analyze the network packets of the encrypted
communication with the server, as well as inject code in third-party
non-encrypted HTTP responses.

Secondly, he is able to issue any number of malicious requests using the user's
cookies (which will be encrypted). This can be achieved by forcing the user's
browser to run a piece of code, such as a Javascript script. This script can be
either hosted on an adversary-controlled website or injected in plain HTTP
responses from third websites. This script is executed when loaded in the user's
browser and issues requests to any URL crafted by the adversary. Figure
\ref{fig:attack_model} elaborates further on this attack mode.

Thirdly, the web service under attack should allow data injection in the
encrypted response plaintext. This data takes the form of a specially crafted
``reflection'' string, e.g. a HTTP GET parameter whose value is included
in the HTML response. The malicious requests will include such reflections
crafted by the adversary.

As the attack progresses the adversary collects network data containing multiple
reflections. Although this data is encrypted, analysis on the lengths of
different response packets in conjunction with the used reflection sequence will
reveal otherwise hidden properties of the private data. At this point the
privacy of the communication between the user and the website is compromised and
the adversary has broken the confidentiality of the messages by effectively
circumventing TLS security.

    \begin{figure}[thpb]
        \centering
            \includegraphics[width=0.48\textwidth]{figures/attack_model.png}
        \caption{The attack model}
        \label{fig:attack_model}
    \end{figure}

\subsection{A motivating example, concepts and notations}\label{subsec:terms}
We now describe a concrete example of the website in the previously described
attack to illustrate the various terms we use in the rest of this paper. The
terms that need be explained include the \textit{rendering function} $f$,
\textit{rendered message} $m$, \textit{secret} $s$, \textit{noise} $v$,
\textit{reflection} $r$ and the distributions $\mathcal{M}$ of secrets and
$\mathcal{V}$ of noise.

In our example, the target of the attack is the website found in the URL
\textit{mail.example.com}. The victim is the user that is logged in this mail
service and whose cookies the adversary uses in his requests (and aims to
learn).

The web page that the adversary exploits is
\textit{mail.example.com/search?query=attack}. This website provides a HTTP GET
parameter called \textit{query} and the adversary uses the reflection string
\textit{attack}. The HTML response is included below:

\begin{lstlisting}[basicstyle=\small\ttfamily]
<div>
    <p>You searched for: attack</p>
    <p>No results found.</p>
</div>
<div>
    Your inbox:
    <ul>
    <li>[Bank] Routing number: 123</li>
    </ul>
</div>
<div>
    <p>Current Time: 12:40:00</p>
</div>
\end{lstlisting}

The server's HTML generator is an instance of the \textit{rendering function}
$f$. This function implements the rendering of the HTML code based on
blueprints.

The output of $f$ is the \textit{rendered message} $m$. This is the generated
HTML response code that contains response data and is rendered by the user's
browser.

The HTML response contains multiple data elements. A data element can be a
\textit{secret}, \textit{noise}, \textit{static}, or a \textit{reflection}.

A \textit{secret} $s$ is any part of the response that the application wishes to
remain private. The adversary wishes to learn information about $s$. Examples of
secrets in an HTML response include private messages, email contents, financial
data, and web security elements like CSRF tokens \cite{de2011automatic}. A
secret's alphabet is generally printable text characters. In our example, the
strings "Bank", which is an email topic, and "Routing number: 123", which is the
email body, are both secrets.

A \textit{reflection} $r$ is a component crafted by the attacker and can be
adaptively transformed as the attack progresses. In our example, the HTTP GET
value "attack" of the parameter "query" is used as a reflection. This string is
included in the response in the message "You searched for: attack". This serves
as an information message for the user and reflects in every search request the
value of the GET parameter "query".

The \textit{noise} $v$ is a value that changes in every request regardless of
the requested content. Examples of noise include timestamps and ads. The noise
follows a random distribution and its alphabet consists of printable characters.
In our example, the string "12:40:00" is noise.

\textit{Static} is any content that remains unchanged across requests. Typical
examples of static data are HTML $<$div$>$ tags and CSS code. Static content is
predictable and thus irrelevant in the attack. Strings like "div", "ul", "Your
inbox:" are considered static in our example.

Secrets and reflections are chosen from the distribution $\mathcal{M}$.
$\mathcal{M}$ in our example contains all routing numbers and 4-letter strings
like "Bank".

Finally, each noise element is chosen from the distribution $\mathcal{V}$. In
our example, $\mathcal{V}$ contains all 24hr timestamps. In every request, a new
noise element is chosen from $\mathcal{V}$. In this case it is "12:40:00".

The compression function $\textrm{Com}$ is the compression algorithm used on the
HTML response plaintext. In our example, this algorithm is DEFLATE, the most
common compression algorithm in the web. The composition of $\textrm{Com}$ and
the rendering function $f$ is the encoding function $\mathcal{K}$.

The encryption function $\textrm{Enc}$ is the encryption algorithm used by the
web server during the communication. The most commonly used symmetric encryption
algorithm today is AES. We use the function $\mathcal{E}$ to describe the
composition of $\textrm{Enc}$ and $\textrm{Com}$.

The input of $\mathcal{E}$ is the message $m$ and its output is the ciphertext
$c$.  This ciphertext is included in the network response packets and is sniffed
by the adversary over-the-wire.

The generation of $m$, its compression and encryption and the transmission over
the network of $c$, as well as the sniffing ability of the adversary, constitute
the reflection oracle that will be further described in following sections.

The adversary issues the attack in stages. In each stage he creates a pool of
reflections and makes malicious requests for each reflection in the pool. An
attack stage ends when the adversary has successfully decrypted a single
character in the secret. He then adaptively changes the reflection pool, based
on the newly stolen character, and continues similarly.
